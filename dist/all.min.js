
/**
 * Experimental import that patches elements that interacts with Shady DOM 
 * such that tree traversal and mutation apis act like they would under
 * Shadow DOM.
 *
 * This import enables interaction with Shady DOM powered custom elements mostly
 * without the need to use `Polymer.dom` and can therefore enable better 
 * interoperation with 3rd party code, libraries, and frameworks that use DOM
 * tree manipulation apis.
 */
(function() {
  var baseFinishDistribute = Polymer.Base._finishDistribute;
  // NOTE: any manipulation of a node must occur in a patched parent
  // so that the parent can cleanup the node's composed and logical 
  // information. We patch an element's parent's to make this rule more 
  // likely to be satisfied.
  // Also note that any use of qS/qSA must be done in a patched node.
  Polymer.Base._finishDistribute = function() {
    baseFinishDistribute.call(this);
    if (!this.__patched) {
      Polymer.dom(this);
      Polymer.dom(this.root);
      Array.prototype.forEach.call(this.childNodes, function(c) {
        Polymer.dom(c);
      });
      // TODO(sorvell): ensure top element's parents are wrapped (helped A2
      // since it uses qSA on the fragment containing stamped custom elements)
      // note that getOwnerRoot will patch all parents but there should be an 
      // explicit easier way to do this. 
      if (!this.dataHost) {
        Polymer.dom(this).getOwnerRoot();
      }
    }
  };
  var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
  var getComposedChildren = Polymer.DomApi.getComposedChildren;
  var nativeShadow = Polymer.Settings.useShadow;
  var excluded = ['head'];
  Polymer.telemetry.patched = 0;
  
  // experimental: support patching selected native api.
  Polymer.DomApi.ctor.prototype.patch = function(force) {
    if (nativeShadow || this.node.__patched || 
      (this.node.localName && excluded.indexOf(this.node.localName) >= 0)) {
      return;
    }
    getComposedChildren(this.node);
    saveLightChildrenIfNeeded(this.node);
    if (!this.node._lightParent) {
      this.node._lightParent = this.node.parentNode;
    }
    if (!this.node._composedParent) {
      this.node._composedParent = this.node.parentNode;
    }
    // TODO(sorvell): correctly patch non-element nodes.
    if (this.node.nodeType !== Node.TEXT_NODE) {
      this.node.__patched = true;
      patchImpl.patch(this.node);
    }
  };
  Polymer.DomApi.ctor.prototype.unpatch = function() {
    this.flush();
    patchImpl.unpatch(this.node);
  };
  Polymer.DomApi.ctor.prototype.remove = function() {
    this.parentNode.removeChild(this.node);
    this.flush();
    this.unpatch();
  };
  var log = false;
  var factory = Polymer.DomApi.factory;
  var patchImpl = {
    
    hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(
      Node.prototype, 'textContent')),
    
    methods: ['appendChild', 'insertBefore', 'removeChild', 'replaceChild',
      'querySelector', 'querySelectorAll', 'getDestinationInsertionPoints', 
      'cloneNode', 'importNode'],
    // <content>: getDistributedNodes
    accessors: ['parentNode', 'childNodes', 
      'firstChild', 'lastChild', 'nextSibling', 'previousSibling',
      'parentElement', 'children',
      'firstElementChild', 'lastElementChild', 
      'nextElementSibling', 'previousElementSibling'
    ],
    writableAccessors: ['textContent', 'innerHTML'],
    protoCache: {},
    
    patch: function(node) {
      Polymer.telemetry.patched++;
      log && console.warn('patch node', node);
      if (this.hasPrototypeDescriptors) {
        this.patchPrototype(node);
      } else {
        this.patchObject(node, true);
      }
    },
    patchPrototype: function(node) {
      var name = node.is || (node.getAttribute && node.getAttribute('is')) ||
        node.localName || node.nodeType;
      var proto = this.protoCache[name];
      if (!proto) {
        proto = this.protoCache[name] = this.createPatchedPrototype(node);
      }
      node.__proto__ = proto;
    },
    createPatchedPrototype: function(node) {
      var sourceProto = node.__proto__;
      var newProto = Object.create(sourceProto);
      newProto.__sourceProto__ = sourceProto;
      this.patchObject(newProto);
      return newProto;
    },
    patchObject: function(obj, cacheAccesors) {
      this.methods.forEach(function(m) {
        this.patchMethod(obj, m);
      }, this);
      this.accessors.forEach(function(n) {
        this.patchAccessor(obj, n, false, cacheAccesors);
      }, this);
      this.writableAccessors.forEach(function(n) {
        this.patchAccessor(obj, n, true, cacheAccesors);
      }, this);
    },
    patchMethod: function(obj, name) {
      var orig = obj[name];
      obj['_$' + name + '$_'] = orig;
      obj[name] = function() {
        log && console.log(this, name, arguments);
        return factory(this)[name].apply(this.__domApi, arguments);
      };
    },
    patchAccessor: function(obj, name, writable, shouldCache) {
      if (shouldCache) {
        this.cacheAccessor(obj, name);
      }
      var info = {
        get: function() {
          log && console.log(this, name);
          return factory(this)[name];
        },
        configurable: true
      };
      if (writable) {
        info.set = function(value) {
          factory(this)[name] = value;
        };
      }
      Object.defineProperty(obj, name, info);
    },
    cacheAccessor: function(obj, name) {
      var cache = obj.__descriptorCache = obj.__descriptorCache || {};
      cache[name] = Object.getOwnPropertyDescriptor(obj, name);
    },
    unpatch: function(obj) {
      if (obj.__sourceProto__) {
        obj.__proto__ = obj.__sourceProto__;
      } else {
        this.methods.forEach(function(m) {
          this.unpatchMethod(obj, m);
        }, this);
        this.accessors.forEach(function(n) {
          this.unpatchAccessor(obj, n);
        }, this);
        this.writableAccessors.forEach(function(n) {
          this.unpatchAccessor(obj, n);
        }, this);
      }
      obj.__patched = false;
    },
    unpatchMethod: function(obj, name) {
      delete obj[name];
    },
    unpatchAccessor: function(obj, name) {
      var info = obj.__descriptorCache[name];
      Object.defineProperty(obj, name, info);
    }
    
  };
  Polymer.DomApi.getLightChildren = function(node) {
    var children = node._lightChildren;
    return children ? children : Polymer.DomApi.getComposedChildren(node);
  }
  Polymer.Base.instanceTemplate = function(template) {
    var m = document._$importNode$_ || document.importNode;
    var dom =
      m.call(document, template._content || template.content, true);
    return dom;
  }
  Polymer.DomApi.patchImpl = patchImpl;
})();
;(function () {
    "use strict";

    var scheedule = angular.module('scheedule', ['ngRoute','ngResource','ngRoute','ui.bootstrap', 'angular-chartist', 'angular.filter']);
    console.log("Initialized Scheedule2 Angular.js application.");

    scheedule.config(['$routeProvider','$locationProvider', function ($routeProvider,$locationProvider) {
        $locationProvider.html5Mode(false);

        $routeProvider
            .when('/', {
                redirectTo  : '/index'
            })
            .when('/index', {
                templateUrl : '/views/index.html',
                controller  : 'IndexController',
                controllerAs: 'index'
            })
            .when('/schedule-viewer', {
                templateUrl : '/views/schedule-viewer.html',
                controller  : 'ScheduleViewerController',
                controllerAs: 'viewer'
            })
            .when('/manual-builder', {
                templateUrl : '/views/manual-builder.html',
                controller  : 'ManualBuilderController',
                controllerAs: 'mb'
            })
            .when('/auto-builder', {
                templateUrl : '/views/auto-builder.html',
                controller  : 'AutoBuilderController',
                controllerAs: 'ab'
            });
    }]);
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('AutoBuilderController', AutoBuilderController);

	/* @ngInject */
	function AutoBuilderController () {
	    var ab = this;

	    ab.init = function () {
	    	console.log("Loaded auto builder controller.");
	    }

	    ab.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('IndexController', IndexController);

	function IndexController () {
    	var index = this;

    	index.init = function () {
    		console.log("Loaded index controller.");

    		index.message = "Angular in action!";
    	}

    	index.init();
	}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .controller('ManualBuilderController', ['CourseDataService', 'AgendaService', ManualBuilderController]);

    // Manual Agenda Builder Controller
    // ----------------
    //
    // Coordinates creating of agenda view, course selection accordions,
    // course searching and agenda/accordion interactions.
    function ManualBuilderController (CourseDataService, AgendaService) {
        var mb = this;
        mb.init = function () {
            console.log("Loaded manual builder controller.");
            mb.courses = [];

            // Load courses from Course Data Service.
            CourseDataService.getCourses(function (someCourses) {
                for (var course of someCourses) {
                    mb.courses.push(course);
                }
            }, function (err) {
                console.log("Couldn't load course data from backend.");
            });

            // Initialize blank agenda.
            mb.agenda = AgendaService.blankAgenda();
        };

        // Fired upon clicking a section.
        mb.clickSection = function (section) {
            if (section.active) {
                // If we're clicking a selected section, clear its active flag.
                // Then remove it from the calendar, and return it to the
                // mouseentered state.
                section.active = false;
                mb.agenda.removeSeriesForSection(section);
                mb.highlightSection(section);
            } else {
                // If we clicked an unselected section, exit the mouseentered
                // state. Set its active flag and add it to the agenda.
                mb.unhighlightSection(section);
                section.active = true;
                mb.agenda.addNormalSeriesForSection(section);
            }
        };

        // Fired when the mosueenter event occurs on a section.
        mb.highlightSection = function (section) {
            // Only add the translucent hover section to the agenda if the section
            // isn't already selected.
            if (!section.active) {
                section.hovering = true;
                mb.agenda.addHoverSeriesForSection(section);
            }
        };

        // Fired when the mosueleave event occurs on a section.
        mb.unhighlightSection = function (section) {
            // Only remove the hover section from the agenda if the section was
            // already being hovered over (i.e. prevent removing selected sections).
            if (section.hovering) {
                section.hovering = false;
                mb.agenda.removeSeriesForSection(section);
            }
        };

        mb.init();
    }
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ScheduleViewerController', ScheduleViewerController);

	/* @ngInject */
	function ScheduleViewerController () {
    	var viewer = this;

    	viewer.init = function () {
    		console.log("Loaded schedule view controller.");
    	}

    	init();
	}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('AgendaModelService', AgendaModelService);

    function AgendaModelService () {
        var ams = this;

        ams.init = function () {
            ams.activeCourses = {};
            ams.operationList = [];
            ams.availableColorIndices = [0,1,2,3,4,5,6,7];
        };

        ams.verifyOperation = function (operation) {
            if (operation.type == "add") {
                return {success: true};
            } else if (operation.type == "add-hover") {
                return {success: true};
            } else if (operation.type == "remove") {
                if (ams.activeCourses[operation.section.courseId][operation.section.id] === undefined) {
                    return {success: false, err: "DOES_NOT_EXIST"};
                }
                return {success: true};
            } else {
                return {success: false, err: "DUPLICATE"};
            }
        };

        ams.mutateSchedule = function (operation, seriesData, errCallback) {
            var verifyStatus = ams.verifyOperation(operation);
            if (verifyStatus.success) {
                ams.operationList.push(operation);
                ams.executeOperation(operation, seriesData);
            } else {
                var shouldContinue = errCallback(verifyStatus.err);
                if (shouldContinue) {
                    ams.executeOperation(operation, seriesData);
                }
            }
        }

        ams.executeOperation = function (operation, seriesData) {
            if (operation.type == "add" || operation.type == "add-hover") {
                ams.executeAddOperation(operation, seriesData);
            } else if (operation.type == "remove") {
                ams.executeRemoveOperation(operation, seriesData);
            }
        };

        ams.executeAddOperation = function (operation, seriesData) {
            var newSeries = [];

            if (operation.type == "add-hover") {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,true));
                }
            } else {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,false));
                }
            }

            // Add course to map of active courses if not already extant
            if (ams.activeCourses[operation.section.courseId] === undefined) {
                // Initialize the active course object with an empty map of secitons
                ams.activeCourses[operation.section.courseId] = {};

                // Color index was already set in ams.seriesPointForSectionDay
                ams.activeCourses[operation.section.courseId].colorIndex = ams.availableColorIndices[0];
                ams.availableColorIndices.splice(0,1);
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                }

                // Add our new series to the calendar
                seriesData.push(newSeries);
                ams.activeCourses[operation.section.courseId].index = seriesData.indexOf(newSeries);

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = 0;

                // Finally, increment the number of sections for our course
                ams.activeCourses[operation.section.courseId].sectionCount = 1;
            } else {
                // Otherwise, just add the new series to the array for our course
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                    seriesData[ams.activeCourses[operation.section.courseId].index].push(seriesPoint);
                }

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = seriesData[ams.activeCourses[operation.section.courseId].index].indexOf(newSeries[0]);
                ams.activeCourses[operation.section.courseId].sectionCount++;
            }
        }

        ams.executeRemoveOperation = function (operation, seriesData) {
            // Get index for our section
            var sectionIndex = ams.activeCourses[operation.section.courseId][operation.section.id];

            // Get course index
            var courseIndex = ams.activeCourses[operation.section.courseId].index;

            // Set entry in our course object for the section to be removed as undefined
            ams.activeCourses[operation.section.courseId][operation.section.id] = undefined;

            // Splice out n entries from our course's array in seriesData starting at our section index, where
            // n is the number of days for our section.
            seriesData[courseIndex].splice(sectionIndex,operation.section.days.length);

            // Iterate over our course object properties to find all entries corresponding to section indecies
            for (var property in ams.activeCourses[operation.section.courseId]) {
                // If the property is strictly numeric...
                if (ams.activeCourses[operation.section.courseId].hasOwnProperty(property) && ams.isNumeric(property)) {
                    // Get the index for each section
                    var candidateSectionIndex = ams.activeCourses[operation.section.courseId][property];
                    // If this candidate index is greater than the index of the section we just removed from
                    // our course's array in seriesData, we have to reindex. Subtract the number of items we
                    // spliced out from the section's index.
                    if (candidateSectionIndex > sectionIndex) {
                        ams.activeCourses[operation.section.courseId][property] -= operation.section.days.length;
                    }
                }
            }
            ams.activeCourses[operation.section.courseId].sectionCount--;
            if (ams.activeCourses[operation.section.courseId].sectionCount == 0) {
                var courseIndex = ams.activeCourses[operation.section.courseId].index;
                ams.availableColorIndices.unshift(ams.activeCourses[operation.section.courseId].colorIndex);
                ams.activeCourses[operation.section.courseId] = undefined;
                seriesData.splice(courseIndex,1);
                // Our course table needs to be reindexed in the same way as above
                for (var property in ams.activeCourses) {
                    if (ams.activeCourses.hasOwnProperty(property) && property != 'index' && property != 'sectionCount' && property != operation.section.courseId && ams.activeCourses[property] !== undefined) {
                        var candidateCourseIndex = ams.activeCourses[property].index;
                        if (candidateCourseIndex > courseIndex) {
                            ams.activeCourses[property].index -= 1;
                        }
                    }
                }
            }
        }

        ams.seriesPointForSectionDay = function (section, day, hover) {
            var point = {
                x: day,
                y: section.startMoment.hours(),
                name: section.name,
                courseName: section.courseName,
                decimalHours: (section.endMoment.unix() - section.startMoment.unix())/3600.0,
                type: "normal"
            };
            if (hover) {
                point.type = "hover";
            }
            return point;
        };

        
        ams.isNumeric = function (num) {
            return !isNaN(parseFloat(num)) && isFinite(num);
        };

        ams.init();
    }
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('AgendaService', ['AgendaModelService', AgendaService]);

    // Agenda Service
    // ----------------
    //
    // Provides API wrapper around an agenda view. Allows for adding sections, removing sections.
    // Uses Agenda Model Service to provide feedback on these operations (adding a duplicate course,
    // removing a non-existent section).
    function AgendaService (AgendaModelService) {
        var as = this;
        var agenda = {};

        // Initialize service. Set displayed hour range.
        // Create functions on chart objects and initialize
        // chart data.
        as.init = function () {
            as.maxHour24 = 18;
            as.minHour24 = 6;

            as.initChartData();
            as.initChartFunctions();    
        };

        // Add functions to calendar object returned by service.
        as.initChartFunctions = function () {

            // Call into model service. Mutate schedule with add operation.
            // Alert "Duplicate section" if adding a duplicate section. Return success value.
            agenda.addNormalSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "add",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DUPLICATE") {
                        alert("Duplaicate section, adding anyway.");
                        return true;
                    }
                    return false;
                });
            };

            // Call into model service. Mutate schedule with add operation.
            // Do not alert "Duplicate section" if adding a duplicate section.
            // Return success value.
            agenda.addHoverSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "add-hover",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DUPLICATE") {
                        alert("Duplaicate section, adding anyway.");
                        return true;
                    }
                    return false;
                });
            };

            // Call into model service. Mutate schedule with remove operation.
            // Alert "non-existent section" if removing a section not on agenda.
            agenda.removeSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "remove",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DOES_NOT_EXIST") {
                        alert("We couldn't find the section you're trying to remove.");
                        return true;
                    }
                    return false;
                });
            };
        }

        // Set up drawing function on chart object, set chart options.
        as.initChartData = function () {
            AgendaModelService.maxHour24 = 18;
            AgendaModelService.minHour24 = 6;
            agenda.chartEvents = {
                draw: function eventHandler(data) {
                    if (data.type === 'point') {
                        var w = data.axisX.axisLength/(data.axisX.ticks.length-1);
                        var newSvgElement = new Chartist.Svg('rect', {
                            x: data.x,
                            y: data.y,
                            width: w,
                            height: data.axisY.options.offset*data.series[data.index].decimalHours,
                            opacity: 1.0
                        }, '');
                        newSvgElement._node.addEventListener('removeFromAgenda', function (e) {
                            newSvgElement.removeClass('agenda-fade-in');
                            newSvgElement.addClass('agenda-fade-out');
                        }, true);
                        if (data.series[data.index].type == "hover") {
                            newSvgElement.addClass('agenda-hover');
                            newSvgElement.addClass('agenda-fade-in');
                            newSvgElement.addClass('agenda-color-hover');
                        } else {
                            newSvgElement.addClass('agenda-color-'+data.series[data.index].colorIndex);
                        }
                        data.element.replace(newSvgElement);
                        data.group.elem('text', {
                            x: data.x,
                            y: data.y+25, 
                            fill: "white"
                        }).text(
                            data.series[data.index].courseName+" - "+data.series[data.index].name
                        );
                    }
                }
            };

            // Label interpolation function determines how our axes are labled.
            agenda.chartOptions = {
                seriesBarDistance: 0,
                showLine: false,
                axisY: {
                    labelInterpolationFnc: function (value) {
                        value = as.minHour24 + as.maxHour24 - value;
                        if (value == 12) {
                            return value + ":00 PM"
                        } else if (value > 12) {
                            value = value % 12;
                            return value + ":00 PM"
                        } else {
                            return value + ":00 AM"
                        }
                    },
                    onlyInteger: true,
                    high: 18,
                    low: 6,
                },
                axisX: {
                    type: Chartist.AutoScaleAxis,
                    high: 5,
                    low: 0,
                    onlyInteger: true,
                    labelInterpolationFnc: function(value) {
                        if (value == 0) {
                            return "Monday";
                        } else if (value == 1) {
                            return "Tuesday";
                        } else if (value == 2) {
                            return "Wednsday";
                        } else if (value == 3) {
                            return "Thursday";
                        } else if (value == 4) {
                            return "Friday";
                        }
                    },
                }
            };

            // Set columns on chart. Set series data to be nothing initially.
            agenda.chartData = {
                labels: ['Monday', 'Tuesday', 'Wednsday', 'Thursday', 'Friday'],
                series: []
            };
        }

        // Return blank agenda object, all set up and ready to be used.
        as.blankAgenda = function () {
            return agenda;
        }

        as.init();
    }
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('CourseDataService', ['$http', CourseDataService]);

    function CourseDataService ($http) {
        var cds = this;
        console.log("Loaded course data service.");

        cds.init = function () {
            cds.timeFormat = "hh:mm a";
            cds.batchAmount = 100;
        }

        cds.getCourses = function (processPartialCourses, processErr) {
            $http.get('/api/all').then(function (courses) {
                cds.formatCourseArray(courses.data,processPartialCourses);
            }, function (err) {
                processErr(err);
            });
        };

        cds.formatCourseArray = function (courses, partialCompletionCallback) {
            var formattedCourses = []
            var i = 0;
            for (var course of courses) {
                if (i > cds.batchAmount) {
                    partialCompletionCallback(formattedCourses);
                    i = 0;
                    formattedCourses = new Array();
                    courses.splice(0,cds.batchAmount);
                    setTimeout(cds.formatCourseArray(courses,partialCompletionCallback),0);
                    return;
                }
                i++;
                var formattedCourse = {
                    shortName: course.Department + " " + course.CourseNumber,
                    longName: course.Name,
                    id: course.ID,
                    sections: []
                };
                for (var section of course.Sections) {
                    formattedCourse.sections = cds.formatSectionsArray(formattedCourse,course.Sections);
                }
                formattedCourses.push(formattedCourse);
            }
            console.log("Finished formatting course array.");
            partialCompletionCallback(formattedCourses);
        }

        cds.formatSectionsArray = function (course, sections) {
            var formattedSections = [];
            for (var section of sections) {
                for (var meeting of section.Meetings) {
                    var days = cds.getDayIndicesFromInitialString(meeting.Days);
                    var startDate = moment(meeting.Start,cds.timeFormat);
                    var endDate = moment(meeting.End,cds.timeFormat);
                    formattedSections.push({
                        id: section.CRN,
                        courseId: course.shortName,
                        courseName: course.shortName,
                        name: section.Code,
                        startMoment: startDate,
                        endMoment: endDate,
                        days: days,
                        active: false,
                        hovering: false
                    });
                }
            }
            return formattedSections;
        }

        cds.getDayIndicesFromInitialString = function (initialString) {
            var days = [];
            for (var letterIndex = 0; letterIndex < initialString.length; letterIndex++) {
                var dayInitial = initialString.charAt(letterIndex);
                if (dayInitial == 'M') {
                    days.push(0);
                } else if (dayInitial == 'T') {
                    days.push(1);
                } else if (dayInitial == 'W') {
                    days.push(2);
                } else if (dayInitial == 'R') {
                    days.push(3);
                } else if (dayInitial == 'F') {
                    days.push(4);
                }
            }
            return days;
        }
        
        cds.init();
    }
})();