(function () {
    "use strict";

    var scheedule = angular.module('scheedule', ['ngRoute','ngResource','ngRoute','ui.bootstrap', 'angular-chartist', 'angular.filter']);
    console.log("Initialized Scheedule2 Angular.js application.");

    scheedule.config(['$routeProvider','$locationProvider', function ($routeProvider,$locationProvider) {
        $locationProvider.html5Mode(false);

        $routeProvider
            .when('/', {
                redirectTo  : '/index'
            })
            .when('/index', {
                templateUrl : '/views/index.html',
                controller  : 'IndexController',
                controllerAs: 'index'
            })
            .when('/schedule-viewer', {
                templateUrl : '/views/schedule-viewer.html',
                controller  : 'ScheduleViewerController',
                controllerAs: 'viewer'
            })
            .when('/manual-builder', {
                templateUrl : '/views/manual-builder.html',
                controller  : 'ManualBuilderController',
                controllerAs: 'mb'
            })
            .when('/auto-builder', {
                templateUrl : '/views/auto-builder.html',
                controller  : 'AutoBuilderController',
                controllerAs: 'ab'
            });
    }]);
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('AutoBuilderController', AutoBuilderController);

	/* @ngInject */
	function AutoBuilderController () {
	    var ab = this;

	    ab.init = function () {
	    	console.log("Loaded auto builder controller.");
	    }

	    ab.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('IndexController', IndexController);

	function IndexController () {
    	var index = this;

    	index.init = function () {
    		console.log("Loaded index controller.");

    		index.message = "Angular in action!";
    	}

    	index.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ManualBuilderController', ['$scope','$rootScope','$filter','AuthService','CourseDataService', 'AgendaService', ManualBuilderController]);

	// Manual Agenda Builder Controller
	// ----------------
	//
	// Coordinates creating of agenda view, course selection accordions,
	// course searching and agenda/accordion interactions.
	function ManualBuilderController ($scope, $rootScope, $filter, AuthService, CourseDataService, AgendaService) {
		var mb = this;
		mb.init = function () {
			console.log("Loaded manual builder controller.");
			mb.courses = [];

			// Load courses from Course Data Service.
			CourseDataService.getCourses(function (someCourses) {
				for (var course of someCourses) {
					$scope.$apply(function () {
						mb.courses.push(course);
					});
				}
			}, function (err) {
				console.log("Couldn't load course data from backend.");
			});

			// Listen for events broadcast from other controllers on the root scope.
			$rootScope.$on('saveSchedule', function () {
				mb.openDialog("save-dialog");
			});

			$rootScope.$on('loadSchedules', function () {
				mb.loadSchedules();
			});

			$rootScope.$on('presentLoginModal', function () {
				mb.openDialog("login-dialog");
			});

			// Initialize blank agenda.
			mb.agenda = AgendaService.blankAgenda();
		};

		// Fired upon clicking a section.
		mb.clickSection = function (section) {
			if (section.active) {
				// If we're clicking a selected section, clear its active flag.
				// Then remove it from the calendar, and return it to the
				// mouseentered state.
				section.active = false;
				mb.agenda.removeSeriesForSection(section);
				mb.highlightSection(section);
			} else {
				// If we clicked an unselected section, exit the mouseentered
				// state. Set its active flag and add it to the agenda.
				mb.unhighlightSection(section);
				section.active = true;
				mb.agenda.addNormalSeriesForSection(section);
			}
		};

		// Fired when the mosueenter event occurs on a section.
		mb.highlightSection = function (section) {
			// Only add the translucent hover section to the agenda if the section
			// isn't already selected.
			if (!section.active) {
				section.hovering = true;
				mb.agenda.addHoverSeriesForSection(section);
			}
		};

		// Fired when the mosueleave event occurs on a section.
		mb.unhighlightSection = function (section) {
			// Only remove the hover section from the agenda if the section was
			// already being hovered over (i.e. prevent removing selected sections).
			if (section.hovering) {
				section.hovering = false;
				mb.agenda.removeSeriesForSection(section);
			}
		};

		mb.deleteCourse = function (course, shouldHover) {
			for (var section of course.sections) {
				if (section.active || section.hovering) {
					section.active = false;
					section.hovering = false;
					mb.agenda.removeSeriesForSection(section);
					if (shouldHover) {
						section.hovering = true;
						mb.highlightSection(section);
					}
				}
			}
		};

		mb.undeleteCourse = function (course) {
			for (var section of course.sections) {
				if (section.hovering) {
					mb.unhighlightSection(section);
					section.active = true;
					mb.agenda.addNormalSeriesForSection(section);
				}
			}
		};

		mb.deleteSchedule = function (schedule) {
			CourseDataService.deleteSchedule(schedule, function () {
				mb.loadSchedules();
			}, function (err) {
				console.log("Error deleting schedule.");
				console.log(err);
			});
		};

		// Save the current set of sections on the calendar.
		mb.saveSchedule = function () {
			console.log("Saving schedule...");
			var CRNList = [];
			// Grab the active section from our list of courses.
			for (var CRN of $filter('ActiveCRNFilter')(mb.courses)) {
				CRNList.push(CRN);
			}
			// Send that list off to the API.
			CourseDataService.saveSchedule(CRNList,mb.scheduleTitle,function () {
				console.log("Saved schedule.");
				// If things went ok, close the save dialog.
				mb.closeDialog("save-dialog");
			}, function (err) {
				// If there was an error (not logged in, not inet access, etc.)
				// display an error dialog.
				console.log("Error saving schedule.");
				console.log(err);
			});
		};

		// Load up a list of schedules to pick from in our load schedules dialog.
		mb.loadSchedules = function () {
			console.log("Loading schedules...");
			// Get the list of schedules from the API.
			CourseDataService.loadSchedules(function (schedules) {
				console.log("Loaded schedules.");
				// Throw the data we got back from the API into the list of possible
				// schedules to load on our load dialog.
				mb.loadedSchedules = schedules
				mb.openDialog("manage-dialog");
			}, function (err) {
				// If we had trouble getting the list of schedules, show an error
				// dialog.
				console.log("Error loading schedules.");
				console.log(err);
			});
		};

		// Display a selected, loaded schedule into our calendar.
		mb.displaySchedule = function () {
			mb.agenda = AgendaService.blankAgenda();
			// Get the HTML element for the list of schedules.
			var scheduleList = document.getElementById("schedule-names");
			// Get the list of CRNs for the selected schedule (this index is set 
			// in the ng-click listener for schedule-names)
			var CRNList = mb.loadedSchedules[mb.selectedScheduleIndex].CRNList;
			var activatedSections = [];
			// Iterate through all CRNs in our list.
			for (var crnIndex = 0; crnIndex < CRNList.length; crnIndex++) {
				// Iterate through all sections in all courses in mb.courses.
				for (var courseIndex = 0; courseIndex < mb.courses.length; courseIndex++) {
					for (var sectionIndex = 0; sectionIndex < mb.courses[courseIndex].sections.length; sectionIndex++) {
						// If the section we're looking at is on our list of CRNs, add it to our calendar.
						// Also add it 
						if (CRNList[crnIndex] == mb.courses[courseIndex].sections[sectionIndex].id && !activatedSections.includes(mb.courses[courseIndex].sections[sectionIndex])) {
							mb.agenda.addNormalSeriesForSection(mb.courses[courseIndex].sections[sectionIndex]);
							mb.courses[courseIndex].sections[sectionIndex].active = true;
							activatedSections.push(mb.courses[courseIndex].sections[sectionIndex]);
						}
					}
				}
			}
			mb.closeDialog("manage-dialog");
		}

		mb.selectSchedule = function (event) {
			var selectedScheduleName = event.target.innerHTML;
			if (selectedScheduleName != "") {
				selectedScheduleName = selectedScheduleName.slice(0, selectedScheduleName.indexOf("<")).trim();
			}
			console.log(selectedScheduleName);
			for (var loadedScheduleIndex = 0; loadedScheduleIndex < mb.loadedSchedules.length; loadedScheduleIndex++) {
				var schedule = mb.loadedSchedules[loadedScheduleIndex];
				if (schedule.name == selectedScheduleName) {
					mb.selectedScheduleIndex = loadedScheduleIndex;
				}
			}
		};

		mb.openDialog = function (name) {
			var dialog = document.getElementById(name);
			dialog.open();
			window.setTimeout(function () {
				dialog.center();
			},1);
		}

		mb.closeDialog = function (name) {
			var dialog = document.getElementById(name);
			dialog.close();
		}

		mb.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ScheduleViewerController', ScheduleViewerController);

	/* @ngInject */
	function ScheduleViewerController () {
    	var viewer = this;

    	viewer.init = function () {
    		console.log("Loaded schedule view controller.");
    	}

    	init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ToolbarController', ['$rootScope',ToolbarController]);

	function ToolbarController ($rootScope) {
		var tc = this;
		tc.init = function () {
			console.log("Loaded toolbar controller.");
		};

		tc.clickSave = function () {
			$rootScope.$broadcast('saveSchedule');
		};

		tc.clickLoad = function () {
			$rootScope.$broadcast('loadSchedules');
		};

		tc.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.filter('ActiveCoursesFilter', ['AgendaModelService', ActiveCoursesFilter]);

		function ActiveCoursesFilter (AgendaModelService) {
			return function(courses) {
				var activeCourses = [];
				angular.forEach(courses, function (course) {
					if (AgendaModelService.activeCourses[course.shortName] !== undefined) {
						activeCourses.push(course);
					}
				});
				return activeCourses;
			};
		}
})();

(function () {
	"use strict";

	angular
		.module('scheedule')
		.filter('ActiveCRNFilter', ['AgendaModelService', ActiveCRNFilter]);

		function ActiveCRNFilter (AgendaModelService) {
			return function(courses) {
				console.log(AgendaModelService.activeCourses);
				var activeSections = [];
				angular.forEach(courses, function (course) {
					if (AgendaModelService.activeCourses[course.shortName] !== undefined) {
						var courseRecord = AgendaModelService.activeCourses[course.shortName];
						for (var property in courseRecord) {
							if (courseRecord.hasOwnProperty(property) && AgendaModelService.isNumeric(property)) {
								if (courseRecord[property] !== undefined) {
									activeSections.push(property);
								}
							}
						}
					}
				});
				console.log(activeSections);
				return activeSections;
			};
		}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('AgendaModelService', AgendaModelService);

    function AgendaModelService () {
        var ams = this;

        ams.init = function () {
            ams.activeCourses = {};
            ams.operationList = [];
            ams.availableColorIndices = [0,1,2,3,4,5,6,7];
        };

        ams.verifyOperation = function (operation) {
            if (operation.type == "add") {
                return {success: true};
            } else if (operation.type == "add-hover") {
                return {success: true};
            } else if (operation.type == "remove") {
                if (ams.activeCourses[operation.section.courseId][operation.section.id] === undefined) {
                    return {success: false, err: "DOES_NOT_EXIST"};
                }
                return {success: true};
            } else {
                return {success: false, err: "DUPLICATE"};
            }
        };

        ams.mutateSchedule = function (operation, seriesData, errCallback) {
            var verifyStatus = ams.verifyOperation(operation);
            if (verifyStatus.success) {
                ams.operationList.push(operation);
                ams.executeOperation(operation, seriesData);
            } else {
                var shouldContinue = errCallback(verifyStatus.err);
                if (shouldContinue) {
                    ams.executeOperation(operation, seriesData);
                }
            }
        }

        ams.executeOperation = function (operation, seriesData) {
            if (operation.type == "add" || operation.type == "add-hover") {
                ams.executeAddOperation(operation, seriesData);
            } else if (operation.type == "remove") {
                ams.executeRemoveOperation(operation, seriesData);
            }
        };

        ams.executeAddOperation = function (operation, seriesData) {
            var newSeries = [];

            if (operation.type == "add-hover") {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,true));
                }
            } else {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,false));
                }
            }

            // Add course to map of active courses if not already extant
            if (ams.activeCourses[operation.section.courseId] === undefined) {
                // Initialize the active course object with an empty map of secitons
                ams.activeCourses[operation.section.courseId] = {};

                // Color index was already set in ams.seriesPointForSectionDay
                ams.activeCourses[operation.section.courseId].colorIndex = ams.availableColorIndices[0];
                ams.availableColorIndices.splice(0,1);
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                }

                // Add our new series to the calendar
                seriesData.push(newSeries);
                ams.activeCourses[operation.section.courseId].index = seriesData.indexOf(newSeries);

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = 0;

                // Finally, increment the number of sections for our course
                ams.activeCourses[operation.section.courseId].sectionCount = 1;
            } else {
                // Otherwise, just add the new series to the array for our course
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                    seriesData[ams.activeCourses[operation.section.courseId].index].push(seriesPoint);
                }

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = seriesData[ams.activeCourses[operation.section.courseId].index].indexOf(newSeries[0]);
                ams.activeCourses[operation.section.courseId].sectionCount++;
            }
        }

        ams.executeRemoveOperation = function (operation, seriesData) {
            // Get index for our section
            var sectionIndex = ams.activeCourses[operation.section.courseId][operation.section.id];

            // Get course index
            var courseIndex = ams.activeCourses[operation.section.courseId].index;

            // Set entry in our course object for the section to be removed as undefined
            ams.activeCourses[operation.section.courseId][operation.section.id] = undefined;

            // Splice out n entries from our course's array in seriesData starting at our section index, where
            // n is the number of days for our section.
            seriesData[courseIndex].splice(sectionIndex,operation.section.days.length);

            // Iterate over our course object properties to find all entries corresponding to section indecies
            for (var property in ams.activeCourses[operation.section.courseId]) {
                // If the property is strictly numeric...
                if (ams.activeCourses[operation.section.courseId].hasOwnProperty(property) && ams.isNumeric(property)) {
                    // Get the index for each section
                    var candidateSectionIndex = ams.activeCourses[operation.section.courseId][property];
                    // If this candidate index is greater than the index of the section we just removed from
                    // our course's array in seriesData, we have to reindex. Subtract the number of items we
                    // spliced out from the section's index.
                    if (candidateSectionIndex > sectionIndex) {
                        ams.activeCourses[operation.section.courseId][property] -= operation.section.days.length;
                    }
                }
            }
            ams.activeCourses[operation.section.courseId].sectionCount--;
            if (ams.activeCourses[operation.section.courseId].sectionCount == 0) {
                var courseIndex = ams.activeCourses[operation.section.courseId].index;
                ams.availableColorIndices.unshift(ams.activeCourses[operation.section.courseId].colorIndex);
                ams.activeCourses[operation.section.courseId] = undefined;
                seriesData.splice(courseIndex,1);
                // Our course table needs to be reindexed in the same way as above
                for (var property in ams.activeCourses) {
                    if (ams.activeCourses.hasOwnProperty(property) && property != 'index' && property != 'sectionCount' && property != operation.section.courseId && ams.activeCourses[property] !== undefined) {
                        var candidateCourseIndex = ams.activeCourses[property].index;
                        if (candidateCourseIndex > courseIndex) {
                            ams.activeCourses[property].index -= 1;
                        }
                    }
                }
            }
        }

        ams.seriesPointForSectionDay = function (section, day, hover) {
            var point = {
                x: day,
                // y: 24 - (section.startMoment.hours()+section.startMoment.minutes()/60.0),
                y: 0,
                name: section.name,
                courseName: section.courseName,
                // decimalHours: (section.endMoment.unix() - section.startMoment.unix())/3600.0,
                decimalHours: 0,
                type: "normal"
            };
            if (hover) {
                point.type = "hover";
            }
            return point;
        };

        
        ams.isNumeric = function (num) {
            return !isNaN(parseFloat(num)) && isFinite(num);
        };

        ams.init();
    }
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.service('AgendaService', ['AgendaModelService', AgendaService]);

	// Agenda Service
	// ----------------
	//
	// Provides API wrapper around an agenda view. Allows for adding sections, removing sections.
	// Uses Agenda Model Service to provide feedback on these operations (adding a duplicate course,
	// removing a non-existent section).
	function AgendaService (AgendaModelService) {
		var as = this;
		var agenda = {};
		as.ams = AgendaModelService;

		// Initialize service. Set displayed hour range.
		// Create functions on chart objects and initialize
		// chart data.
		as.init = function () {
			as.initChartData();
			as.initChartFunctions();    
		};

		// Add functions to calendar object returned by service.
		as.initChartFunctions = function () {

			// Call into model service. Mutate schedule with add operation.
			// Alert "Duplicate section" if adding a duplicate section. Return success value.
			agenda.addNormalSeriesForSection = function (section) {
				AgendaModelService.mutateSchedule({
					type: "add",
					section: section,
				},
				agenda.chartData.series,
				function (err) {
					if (err == "DUPLICATE") {
						alert("Duplaicate section, adding anyway.");
						return true;
					}
					return false;
				});
			};

			// Call into model service. Mutate schedule with add operation.
			// Do not alert "Duplicate section" if adding a duplicate section.
			// Return success value.
			agenda.addHoverSeriesForSection = function (section) {
				AgendaModelService.mutateSchedule({
					type: "add-hover",
					section: section,
				},
				agenda.chartData.series,
				function (err) {
					if (err == "DUPLICATE") {
						alert("Duplaicate section, adding anyway.");
						return true;
					}
					return false;
				});
			};

			// Call into model service. Mutate schedule with remove operation.
			// Alert "non-existent section" if removing a section not on agenda.
			agenda.removeSeriesForSection = function (section) {
				AgendaModelService.mutateSchedule({
					type: "remove",
					section: section,
				},
				agenda.chartData.series,
				function (err) {
					if (err == "DOES_NOT_EXIST") {
						alert("We couldn't find the section you're trying to remove.");
						return true;
					}
					return false;
				});
			};
		}

		// Set up drawing function on chart object, set chart options.
		as.initChartData = function () {
			agenda.chartEvents = {
				draw: function eventHandler(data) {
					if (data.type === 'point') {
						var yScale = data.axisY.axisLength/(data.axisY.ticks.length)/1.70;
						var w = data.axisX.axisLength/(data.axisX.ticks.length-1);
						var newSvgElement = new Chartist.Svg('rect', {
							x: data.x+2,
							y: data.y+2,
							rx: 3,
							ry: 3,
							width: w-4,
							height: data.series[data.index].decimalHours*yScale-4,
							opacity: 1.0
						}, '');
						if (data.series[data.index].type == "hover") {
							newSvgElement.addClass('agenda-hover');
							newSvgElement.addClass('agenda-fade-in');
							newSvgElement.addClass('agenda-color-hover');
						} else {
							newSvgElement.addClass('agenda-color-'+data.series[data.index].colorIndex);
						}
						data.element.replace(newSvgElement);
						data.group.elem('text', {
							x: data.x+4,
							y: data.y+25, 
							fill: "white"
						}).text(
							data.series[data.index].courseName+" - "+data.series[data.index].name
						);
					}
				}
			};

			// Label interpolation function determines how our axes are labled.
			agenda.chartOptions = {
				seriesBarDistance: 0,
				showLine: false,
				axisY: {
					labelInterpolationFnc: function (value) {
						value = 24 - value;
						if (value == 12) {
							return value + ":00 PM"
						} else if (value > 12) {
							value = value % 12;
							return value + ":00 PM"
						} else {
							return value + ":00 AM"
						}
					},
					onlyInteger: true,
					high: 18,
					low: 6,
				},
				axisX: {
					type: Chartist.AutoScaleAxis,
					high: 5,
					low: 0,
					onlyInteger: true,
					labelInterpolationFnc: function(value) {
						if (value == 0) {
							return "Monday";
						} else if (value == 1) {
							return "Tuesday";
						} else if (value == 2) {
							return "Wednsday";
						} else if (value == 3) {
							return "Thursday";
						} else if (value == 4) {
							return "Friday";
						}
					},
				}
			};

			// Set columns on chart. Set series data to be nothing initially.
			agenda.chartData = {
				labels: ['Monday', 'Tuesday', 'Wednsday', 'Thursday', 'Friday'],
				series: []
			};
		}

		// Return blank agenda object, all set up and ready to be used.
		as.blankAgenda = function () {
			return agenda;
		}

		as.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.service('AuthService', AuthService);

	function AuthService () {
		var as = this;

		as.init = function () {
			window.onSignIn = as.onSignIn;
		};

		as.onSignIn = function (googleUser) {
			var id_token = googleUser.getAuthResponse().id_token;
			console.log(id_token);
			$.post('/api/oauth/', {token: id_token});
		};

		as.init();
	}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('CourseDataService', ['$http', CourseDataService]);

    function CourseDataService ($http) {
        var cds = this;
        console.log("Loaded course data service.");

        cds.init = function () {
            cds.timeFormat = "hh:mm a";
        }

        cds.getCourses = function (processPartialCourses, processErr) {
            $http.get('/api/prx/course/all').then(function (courses) {
                cds.tempCourseData = courses.data;
                cds.courseToProcessIndex = 0;
                setTimeout(function () {
                    cds.formatCourseArray(processPartialCourses);
                }, 1);
            }, function (err) {
                processErr(err);
            });
        };

        cds.saveSchedule = function (CRNList, name, processSuccess, processErr) {
            $http.put('/api/prx/schedule', {name: name, CRNList: CRNList}).then(function () {
                console.log({name: name, CRNList: CRNList});
                processSuccess();
            }, function (err) {
                processErr(err);
            });
        }

        cds.loadSchedules = function (processSchedules, processErr) {
            $http.get('/api/prx/schedule').then(function (schedules) {
                processSchedules(schedules.data);
                console.log(schedules);
            }, function (err) {
                processErr(err);
            });
        }

        cds.deleteSchedule = function (schedule, processSuccess, processErr) {
            console.log(schedule.name);
            $http.delete('/api/prx/schedule?' + $.param({name: schedule.name})).then(function () {
                processSuccess();
            }, function (err) {
                processErr(err);
            });
        }

        // cds.formatCourseArray = function (partialCompletionCallback) {
        //     var course = cds.tempCourseData[cds.courseToProcessIndex];
        //     var formattedCourse = {
        //         shortName: course.department + " " + course.courseNumber,
        //         longName: course.name,
        //         id: course.id,
        //         sections: []
        //     };
        //     for (var section of course.sections) {
        //         formattedCourse.sections = cds.formatSectionsArray(formattedCourse,course.sections);
        //     }
        //     partialCompletionCallback([formattedCourse]);
        //     cds.courseToProcessIndex++;
        //     if (cds.courseToProcessIndex < cds.tempCourseData.length) {
        //         setTimeout(function () {
        //             cds.formatCourseArray(partialCompletionCallback);
        //         },0);
        //     }
        //     // console.log("Finished formatting course array.");
        // }

        cds.formatCourseArray = function (partialCompletionCallback) {
            var formattedCourses = [];
            for (var course of cds.tempCourseData) {
                var formattedCourse = {
                    shortName: course.department + " " + course.courseNumber,
                    longName: course.name,
                    id: course.id,
                    sections: []
                };
                for (var section of course.sections) {
                    formattedCourse.sections = cds.formatSectionsArray(formattedCourse,course.sections);
                }
                formattedCourses.push(formattedCourse);
            }
            partialCompletionCallback(formattedCourses);
        }

        cds.formatSectionsArray = function (course, sections) {
            var formattedSections = [];
            for (var section of sections) {
                for (var meeting of section.meetings) {
                    var days = cds.getDayIndicesFromInitialString(meeting.days);
                    // var startDate = moment(meeting.start,cds.timeFormat);
                    // var endDate = moment(meeting.end,cds.timeFormat);
                    formattedSections.push({
                        id: section.crn,
                        courseId: course.shortName,
                        courseName: course.shortName,
                        name: section.code,
                        // startMoment: startDate,
                        // endMoment: endDate,
                        days: days,
                        active: false,
                        hovering: false
                    });
                }
            }
            return formattedSections;
        }

        cds.getDayIndicesFromInitialString = function (initialString) {
            var days = [];
            for (var letterIndex = 0; letterIndex < initialString.length; letterIndex++) {
                var dayInitial = initialString.charAt(letterIndex);
                if (dayInitial == 'M') {
                    days.push(0);
                } else if (dayInitial == 'T') {
                    days.push(1);
                } else if (dayInitial == 'W') {
                    days.push(2);
                } else if (dayInitial == 'R') {
                    days.push(3);
                } else if (dayInitial == 'F') {
                    days.push(4);
                }
            }
            return days;
        }
        
        cds.init();
    }
})();